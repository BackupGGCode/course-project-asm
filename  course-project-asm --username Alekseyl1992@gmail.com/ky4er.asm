;тестировочный проект (ky4er)

;;;;;; OFFTOPIC
; все-таки стандартный шрифт 8x16... my bad
; меня подвел русификатор keyrus (хохляцкий)
; которым я давно пользовался
; Как оказалось, он не совсем корректно работает с
; таблицей символов (ну или я дурак, хз)
; в общем с русификатором rkm (спасибо С.А.)
; все работает хорошо
;;;;;; OFFTOPIC

code segment 'code'
assume CS:code, DS:code, ES:code

org 100h

start:
	push CS
	pop DS
	push CS
	pop ES

	not cursiveEnabled
	call setCursive

; > ТОЛЬКО ДЛЯ ПРОВЕРКИ!!!!
	not cursiveEnabled
; > ждем нажатия любой кнопки	
	mov ah, 07h
	int 21h
; > перевод обратно
	call setCursive
; > END

; выход
	mov AX, 4c00h
	int 21h

setCursive proc
	cmp cursiveEnabled, true
	jne _restoreSymbol
; если флаг равен true, выполняем замену символа на курсивный вариант,
; предварительно сохраняя старый символ в savedSymbol
	
	call saveFont
	mov CL, charToCursiveIndex
_shifTtable:
; мы получаем в bp таблицу всех символов. адрес указывает на символ 0
; поэтому нуэно совершить сдвиг 16*X - где X - код символа
	add bp, 16
	loop _shiftTable
	
; пpи savefont смещается pегистp ES
; поэтомy пpиходится делать такие махинации, чтобы 
; записать полyченный элемент туда, куда нам нужно (в stored_symbol)
;
; тут возможно, можно изяшнее сделать, но я чет краб =(
;
	push DS
	pop AX
	push ES
	pop DS
	push AX
	pop ES
	push AX
;	
	mov SI, BP
	lea DI, savedSymbol
; сохpаняем в пеpеменнyю stored_symbol
; таблицy нyжного символа
	mov CX, 16
; для себя
; movsb из DS:si в ES:di
	rep movsb
; исходные позиции сегментов возвpащены	
	pop DS	
;>!!!

; заменим написание символа на кypсив
	mov CX, 1
	mov DH, 0
	mov DL, charToCursiveIndex
	lea BP, cursiveSymbol
	call changeFont
	jmp _exitSetCursive
	
_restoreSymbol:	
; если флаг равен 0, выполняем замену курсивного символа на старый вариант

	mov CX, 1
	mov DH, 0
	mov DL, charToCursiveIndex
	lea bp, savedSymbol
	call changeFont
	
_exitSetCursive:
	ret
setCursive endp	
	
	
; *** входные данные
; dl = номер символа для замены
; CX = Кол-во символов заменяемых изображений символов
; (начиная с символа указанного в DX)
; ES:bp = адрес таблицы
;
; *** описание работы процедуры
; Происходит вызов int 10h (видеосервис)
; с функцией AH = 11h (функции знакогенератора)
; Параметр AL = 0 сообщает, что будет заменено изображение
; символа для текущего шрифта
; В случаях, когда AL = 1 или 2, будет заменено изображение
; только для опредленного шрифта (8x14 и 8x8 соответственно)
; Параметр BH = 0Eh сообщает, что на опредление каждого изображения символа
; расходуется по 14 байт (режим 8x14 бит как раз 14 байт)
; Параметр BL = 0 - блок шрифта для загрузки (от 0 до 4)
; ??? не совсем понял суть данного параметра
;
; *** результат
; изображение указанного(ых) символа(ов) будет заменено
; на предложенное пользователем.
; Изменению подвергнутся все символы, находящиеся на экране,
; то есть если изображение заменено, старый вариант нигде уже не проявится

changeFont proc
	push AX
	push BX
	mov AX, 1100h
	mov BX, 1000h
	int 10h
	pop AX
	pop BX
	ret
changeFont endp

; *** входные данные
; bh - тип возвращаемой символьной таблицы
;   0 - таблица из int 1fh
;   1 - таблица из int 44h
;   2-5 - таблица из 8x14, 8x8, 8x8 (top), 9x14
;   6 - 8x16
;;;; OFFTOP
; это просто пиздец
; нигде не написано , что 8x16 - это bh=6
; нашел только тут http://www.htl-steyr.ac.at/~morg/pcinfo/hardware/interrupts/inte6rg0.htm
; каким образом, я не знаю.
; если найдете эту же информацию где-нить на норм сайте
; то значит я не умею гуглить, извините
;;;; OFFTOP
;
; *** описание работы процедуры
; Происходит вызов int 10h (видеосервис)
; с функцией AH = 11h (функции знакогенератора)
; Параметр AL = 30 - подфункция получения информации о EGA
; про bl ничего не написано, но лучше обнулять
; у меня вроде баговало, когда в bl были рандомные значения
; но это не 100% инфа
;
; *** результат
; в ES:bp находится таблица символов (полная)
; в CX находится байт на символ
; в dl количество экранных строк
; ВАЖНО! Происходит сдвиг регистра ES
; ( ES становится равным C000h )

saveFont proc
	push AX
	push BX
	mov AX, 1130h
	mov BX, 0600h
	int 10h
	pop AX
	pop BX
	ret
saveFont endp

; от верхней строки, до нижней
cursiveSymbol DB 00000000b
       DB 00000000b
       DB 00000000b
       DB 00111110b
       DB 00111111b
       DB 00110011b
       DB 01100110b
       DB 01100110b
       DB 01111100b
       DB 11000110b
       DB 11000110b
       DB 11000110b
       DB 11111100b
       DB 00000000b
       DB 00000000b
       DB 00000000b
	
; символ для замены	
charToCursiveIndex DB 'В'
; переменная для хранения старого символа
savedSymbol DB 16 dup(0ffh)
cursiveEnabled DB 0
true 						equ	0ffh							; константа истинности

code enDS
end start